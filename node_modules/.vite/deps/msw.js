import {
  dist_exports,
  graphql_exports,
  init_dist,
  init_graphql,
  require_InteractiveIsomorphicRequest,
  require_Interceptor,
  require_IsomorphicRequest,
  require_XMLHttpRequest,
  require_browser,
  require_bufferUtils,
  require_cookie,
  require_getCleanUrl,
  require_glossary,
  require_js_levenshtein,
  require_lib,
  require_lib2,
  require_lib3,
  require_lib4,
  require_lib5,
  require_lib6,
  require_lib7,
  require_toIsoResponse
} from "./chunk-YQBQLLLO.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-TIUEEL27.js";

// node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchInterceptor = void 0;
    var headers_polyfill_1 = require_lib3();
    var outvariant_1 = require_lib();
    var until_1 = require_lib2();
    var IsomorphicRequest_1 = require_IsomorphicRequest();
    var glossary_1 = require_glossary();
    var Interceptor_1 = require_Interceptor();
    var toIsoResponse_1 = require_toIsoResponse();
    var InteractiveIsomorphicRequest_1 = require_InteractiveIsomorphicRequest();
    var FetchInterceptor = (
      /** @class */
      function(_super) {
        __extends(FetchInterceptor2, _super);
        function FetchInterceptor2() {
          return _super.call(this, FetchInterceptor2.symbol) || this;
        }
        FetchInterceptor2.prototype.checkEnvironment = function() {
          return typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined";
        };
        FetchInterceptor2.prototype.setup = function() {
          var _this = this;
          var pureFetch = globalThis.fetch;
          outvariant_1.invariant(!pureFetch[glossary_1.IS_PATCHED_MODULE], 'Failed to patch the "fetch" module: already patched.');
          globalThis.fetch = function(input, init) {
            return __awaiter(_this, void 0, void 0, function() {
              var request, url, method, body, requestUrl, isomorphicRequest, interactiveIsomorphicRequest, _a, middlewareException, mockedResponse, error, isomorphicResponse, response;
              var _this2 = this;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    request = new Request(input, init);
                    url = typeof input === "string" ? input : input.url;
                    method = request.method;
                    this.log("[%s] %s", method, url);
                    return [4, request.clone().arrayBuffer()];
                  case 1:
                    body = _b.sent();
                    requestUrl = new URL(url, typeof location !== "undefined" ? location.origin : void 0);
                    isomorphicRequest = new IsomorphicRequest_1.IsomorphicRequest(requestUrl, {
                      body,
                      method,
                      headers: new headers_polyfill_1.Headers(request.headers),
                      credentials: request.credentials
                    });
                    interactiveIsomorphicRequest = new InteractiveIsomorphicRequest_1.InteractiveIsomorphicRequest(isomorphicRequest);
                    this.log("isomorphic request", interactiveIsomorphicRequest);
                    this.log('emitting the "request" event for %d listener(s)...', this.emitter.listenerCount("request"));
                    this.emitter.emit("request", interactiveIsomorphicRequest);
                    this.log("awaiting for the mocked response...");
                    return [4, until_1.until(function() {
                      return __awaiter(_this2, void 0, void 0, function() {
                        var _a2, mockedResponse2;
                        return __generator(this, function(_b2) {
                          switch (_b2.label) {
                            case 0:
                              return [4, this.emitter.untilIdle("request", function(_a3) {
                                var _b3 = __read(_a3.args, 1), request2 = _b3[0];
                                return request2.id === interactiveIsomorphicRequest.id;
                              })];
                            case 1:
                              _b2.sent();
                              this.log("all request listeners have been resolved!");
                              return [4, interactiveIsomorphicRequest.respondWith.invoked()];
                            case 2:
                              _a2 = __read.apply(void 0, [_b2.sent(), 1]), mockedResponse2 = _a2[0];
                              this.log("event.respondWith called with:", mockedResponse2);
                              return [2, mockedResponse2];
                          }
                        });
                      });
                    })];
                  case 2:
                    _a = __read.apply(void 0, [_b.sent(), 2]), middlewareException = _a[0], mockedResponse = _a[1];
                    if (middlewareException) {
                      console.error(request.method + " " + request.url + " net::ERR_FAILED");
                      error = Object.assign(new TypeError("Failed to fetch"), {
                        cause: middlewareException
                      });
                      return [2, Promise.reject(error)];
                    }
                    if (mockedResponse) {
                      this.log("received mocked response:", mockedResponse);
                      isomorphicResponse = toIsoResponse_1.toIsoResponse(mockedResponse);
                      this.log("derived isomorphic response:", isomorphicResponse);
                      this.emitter.emit("response", interactiveIsomorphicRequest, isomorphicResponse);
                      response = new Response(mockedResponse.body, __assign(__assign({}, isomorphicResponse), {
                        // `Response.headers` cannot be instantiated with the `Headers` polyfill.
                        // Apparently, it halts if the `Headers` class contains unknown properties
                        // (i.e. the internal `Headers.map`).
                        headers: headers_polyfill_1.flattenHeadersObject(mockedResponse.headers || {})
                      }));
                      Object.defineProperty(response, "url", {
                        writable: false,
                        enumerable: true,
                        configurable: false,
                        value: interactiveIsomorphicRequest.url.href
                      });
                      return [2, response];
                    }
                    this.log("no mocked response received!");
                    return [2, pureFetch(request).then(function(response2) {
                      return __awaiter(_this2, void 0, void 0, function() {
                        var cloneResponse, _a2, _b2, _c;
                        return __generator(this, function(_d) {
                          switch (_d.label) {
                            case 0:
                              cloneResponse = response2.clone();
                              this.log("original fetch performed", cloneResponse);
                              _b2 = (_a2 = this.emitter).emit;
                              _c = [
                                "response",
                                interactiveIsomorphicRequest
                              ];
                              return [4, normalizeFetchResponse(cloneResponse)];
                            case 1:
                              _b2.apply(_a2, _c.concat([_d.sent()]));
                              return [2, response2];
                          }
                        });
                      });
                    })];
                }
              });
            });
          };
          Object.defineProperty(globalThis.fetch, glossary_1.IS_PATCHED_MODULE, {
            enumerable: true,
            configurable: true,
            value: true
          });
          this.subscriptions.push(function() {
            Object.defineProperty(globalThis.fetch, glossary_1.IS_PATCHED_MODULE, {
              value: void 0
            });
            globalThis.fetch = pureFetch;
            _this.log('restored native "globalThis.fetch"!', globalThis.fetch.name);
          });
        };
        FetchInterceptor2.symbol = Symbol("fetch");
        return FetchInterceptor2;
      }(Interceptor_1.Interceptor)
    );
    exports.FetchInterceptor = FetchInterceptor;
    function normalizeFetchResponse(response) {
      return __awaiter(this, void 0, void 0, function() {
        var _a;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = {
                status: response.status,
                statusText: response.statusText,
                headers: headers_polyfill_1.objectToHeaders(headers_polyfill_1.headersToObject(response.headers))
              };
              return [4, response.text()];
            case 1:
              return [2, (_a.body = _b.sent(), _a)];
          }
        });
      });
    }
  }
});

// node_modules/msw/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/msw/lib/index.js"(exports, module) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      GraphQLHandler: () => GraphQLHandler,
      MockedRequest: () => MockedRequest,
      RESTMethods: () => RESTMethods,
      RequestHandler: () => RequestHandler,
      RestHandler: () => RestHandler,
      SetupApi: () => SetupApi,
      SetupWorkerApi: () => SetupWorkerApi,
      cleanUrl: () => cleanUrl,
      compose: () => compose,
      context: () => context_exports,
      createResponseComposition: () => createResponseComposition,
      defaultContext: () => defaultContext,
      defaultResponse: () => defaultResponse,
      graphql: () => graphql,
      graphqlContext: () => graphqlContext,
      handleRequest: () => handleRequest,
      matchRequestUrl: () => matchRequestUrl,
      response: () => response,
      rest: () => rest,
      restContext: () => restContext,
      setupWorker: () => setupWorker
    });
    module.exports = __toCommonJS2(src_exports);
    var context_exports = {};
    __export(context_exports, {
      body: () => body,
      cookie: () => cookie,
      data: () => data,
      delay: () => delay,
      errors: () => errors,
      extensions: () => extensions,
      fetch: () => fetch,
      json: () => json,
      set: () => set,
      status: () => status,
      text: () => text,
      xml: () => xml
    });
    var codes_default = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    var status = (statusCode, statusText) => {
      return (res) => {
        res.status = statusCode;
        res.statusText = statusText || codes_default[String(statusCode)];
        return res;
      };
    };
    var import_headers_polyfill = require_lib3();
    function set(...args) {
      return (res) => {
        const [name, value] = args;
        if (typeof name === "string") {
          res.headers.append(name, value);
        } else {
          const headers = (0, import_headers_polyfill.objectToHeaders)(name);
          headers.forEach((value2, name2) => {
            res.headers.append(name2, value2);
          });
        }
        return res;
      };
    }
    var cookieUtils = __toESM(require_cookie());
    var cookie = (name, value, options) => {
      return (res) => {
        const serializedCookie = cookieUtils.serialize(name, value, options);
        res.headers.append("Set-Cookie", serializedCookie);
        if (typeof document !== "undefined") {
          document.cookie = serializedCookie;
        }
        return res;
      };
    };
    var body = (value) => {
      return (res) => {
        res.body = value;
        return res;
      };
    };
    function jsonParse(value) {
      try {
        return JSON.parse(value);
      } catch (error2) {
        return void 0;
      }
    }
    function isObject(value) {
      return value != null && typeof value === "object" && !Array.isArray(value);
    }
    function mergeRight(left, right) {
      return Object.entries(right).reduce((result, [key, rightValue]) => {
        const leftValue = result[key];
        if (Array.isArray(leftValue) && Array.isArray(rightValue)) {
          result[key] = leftValue.concat(rightValue);
          return result;
        }
        if (isObject(leftValue) && isObject(rightValue)) {
          result[key] = mergeRight(leftValue, rightValue);
          return result;
        }
        result[key] = rightValue;
        return result;
      }, Object.assign({}, left));
    }
    var json = (body2) => {
      return (res) => {
        res.headers.set("Content-Type", "application/json");
        res.body = JSON.stringify(body2);
        return res;
      };
    };
    var data = (payload) => {
      return (res) => {
        const prevBody = jsonParse(res.body) || {};
        const nextBody = mergeRight(prevBody, { data: payload });
        return json(nextBody)(res);
      };
    };
    var extensions = (payload) => {
      return (res) => {
        const prevBody = jsonParse(res.body) || {};
        const nextBody = mergeRight(prevBody, { extensions: payload });
        return json(nextBody)(res);
      };
    };
    var import_is_node_process = require_lib7();
    var SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;
    var MIN_SERVER_RESPONSE_TIME = 100;
    var MAX_SERVER_RESPONSE_TIME = 400;
    var NODE_SERVER_RESPONSE_TIME = 5;
    var getRandomServerResponseTime = () => {
      if ((0, import_is_node_process.isNodeProcess)()) {
        return NODE_SERVER_RESPONSE_TIME;
      }
      return Math.floor(
        Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME
      );
    };
    var delay = (durationOrMode) => {
      return (res) => {
        let delayTime;
        if (typeof durationOrMode === "string") {
          switch (durationOrMode) {
            case "infinite": {
              delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;
              break;
            }
            case "real": {
              delayTime = getRandomServerResponseTime();
              break;
            }
            default: {
              throw new Error(
                `Failed to delay a response: unknown delay mode "${durationOrMode}". Please make sure you provide one of the supported modes ("real", "infinite") or a number to "ctx.delay".`
              );
            }
          }
        } else if (typeof durationOrMode === "undefined") {
          delayTime = getRandomServerResponseTime();
        } else {
          if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {
            throw new Error(
              `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for "setTimeout" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the "infinite" delay mode to delay the response indefinitely.`
            );
          }
          delayTime = durationOrMode;
        }
        res.delay = delayTime;
        return res;
      };
    };
    var errors = (errorsList) => {
      return (res) => {
        if (errorsList == null) {
          return res;
        }
        const prevBody = jsonParse(res.body) || {};
        const nextBody = mergeRight(prevBody, { errors: errorsList });
        return json(nextBody)(res);
      };
    };
    var import_is_node_process2 = require_lib7();
    var import_headers_polyfill2 = require_lib3();
    var useFetch = (0, import_is_node_process2.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(require_browser())).then(
      ({ default: nodeFetch }) => nodeFetch(input, init)
    ) : globalThis.fetch;
    var augmentRequestInit = (requestInit) => {
      const headers = new import_headers_polyfill2.Headers(requestInit.headers);
      headers.set("x-msw-bypass", "true");
      return {
        ...requestInit,
        headers: headers.all()
      };
    };
    var createFetchRequestParameters = (input) => {
      const { body: body2, method } = input;
      const requestParameters = {
        ...input,
        body: void 0
      };
      if (["GET", "HEAD"].includes(method)) {
        return requestParameters;
      }
      if (typeof body2 === "object" || typeof body2 === "number" || typeof body2 === "boolean") {
        requestParameters.body = JSON.stringify(body2);
      } else {
        requestParameters.body = body2;
      }
      return requestParameters;
    };
    var fetch = (input, requestInit = {}) => {
      if (typeof input === "string") {
        return useFetch(input, augmentRequestInit(requestInit));
      }
      const requestParameters = createFetchRequestParameters(input);
      const derivedRequestInit = augmentRequestInit(requestParameters);
      return useFetch(input.url.href, derivedRequestInit);
    };
    var text = (body2) => {
      return (res) => {
        res.headers.set("Content-Type", "text/plain");
        res.body = body2;
        return res;
      };
    };
    var xml = (body2) => {
      return (res) => {
        res.headers.set("Content-Type", "text/xml");
        res.body = body2;
        return res;
      };
    };
    var import_outvariant2 = require_lib();
    var import_outvariant = require_lib();
    var LIBRARY_PREFIX = "[MSW]";
    function formatMessage(message, ...positionals) {
      const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);
      return `${LIBRARY_PREFIX} ${interpolatedMessage}`;
    }
    function warn(message, ...positionals) {
      console.warn(formatMessage(message, ...positionals));
    }
    function error(message, ...positionals) {
      console.error(formatMessage(message, ...positionals));
    }
    var devUtils = {
      formatMessage,
      warn,
      error
    };
    function checkGlobals() {
      (0, import_outvariant2.invariant)(
        typeof URL !== "undefined",
        devUtils.formatMessage(
          `Global "URL" class is not defined. This likely means that you're running MSW in an environment that doesn't support all Node.js standard API (e.g. React Native). If that's the case, please use an appropriate polyfill for the "URL" class, like "react-native-url-polyfill".`
        )
      );
    }
    var import_outvariant5 = require_lib();
    var import_is_node_process3 = require_lib7();
    var import_until4 = require_lib2();
    var import_until = require_lib2();
    function getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {
      const allStates = [
        registration.active,
        registration.installing,
        registration.waiting
      ];
      const relevantStates = allStates.filter((state) => {
        return state != null;
      });
      const worker = relevantStates.find((worker2) => {
        return findWorker(worker2.scriptURL, absoluteWorkerUrl);
      });
      return worker || null;
    }
    function getAbsoluteWorkerUrl(workerUrl) {
      return new URL(workerUrl, location.href).href;
    }
    var getWorkerInstance = async (url, options = {}, findWorker) => {
      const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);
      const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(
        (registrations) => registrations.filter(
          (registration) => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)
        )
      );
      if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {
        location.reload();
      }
      const [existingRegistration] = mockRegistrations;
      if (existingRegistration) {
        return existingRegistration.update().then(() => {
          return [
            getWorkerByRegistration(
              existingRegistration,
              absoluteWorkerUrl,
              findWorker
            ),
            existingRegistration
          ];
        });
      }
      const [error2, instance] = await (0, import_until.until)(
        async () => {
          const registration = await navigator.serviceWorker.register(url, options);
          return [
            getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),
            registration
          ];
        }
      );
      if (error2) {
        const isWorkerMissing = error2.message.includes("(404)");
        if (isWorkerMissing) {
          const scopeUrl = new URL((options == null ? void 0 : options.scope) || "/", location.href);
          throw new Error(
            devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.

Did you forget to run "npx msw init <PUBLIC_DIR>"?

Learn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`)
          );
        }
        throw new Error(
          devUtils.formatMessage(
            "Failed to register the Service Worker:\n\n%s",
            error2.message
          )
        );
      }
      return instance;
    };
    function printStartMessage(args = {}) {
      if (args.quiet) {
        return;
      }
      const message = args.message || "Mocking enabled.";
      console.groupCollapsed(
        `%c${devUtils.formatMessage(message)}`,
        "color:orangered;font-weight:bold;"
      );
      console.log(
        "%cDocumentation: %chttps://mswjs.io/docs",
        "font-weight:bold",
        "font-weight:normal"
      );
      console.log("Found an issue? https://github.com/mswjs/msw/issues");
      if (args.workerUrl) {
        console.log("Worker script URL:", args.workerUrl);
      }
      if (args.workerScope) {
        console.log("Worker scope:", args.workerScope);
      }
      console.groupEnd();
    }
    async function enableMocking(context2, options) {
      var _a, _b;
      context2.workerChannel.send("MOCK_ACTIVATE");
      await context2.events.once("MOCKING_ENABLED");
      if (context2.isMockingEnabled) {
        devUtils.warn(
          `Found a redundant "worker.start()" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this "worker.start()" call.`
        );
        return;
      }
      context2.isMockingEnabled = true;
      printStartMessage({
        quiet: options.quiet,
        workerScope: (_a = context2.registration) == null ? void 0 : _a.scope,
        workerUrl: (_b = context2.worker) == null ? void 0 : _b.scriptURL
      });
    }
    var WorkerChannel = class {
      constructor(port) {
        this.port = port;
      }
      postMessage(event, ...rest2) {
        const [data2, transfer] = rest2;
        this.port.postMessage({ type: event, data: data2 }, { transfer });
      }
    };
    var NetworkError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "NetworkError";
      }
    };
    var import_interceptors2 = require_lib4();
    var import_headers_polyfill5 = require_lib3();
    var cookieUtils3 = __toESM(require_cookie());
    var import_cookies = require_lib6();
    var import_interceptors = require_lib4();
    var import_bufferUtils = require_bufferUtils();
    var import_headers_polyfill4 = require_lib3();
    var cookieUtils2 = __toESM(require_cookie());
    function getAllCookies() {
      return cookieUtils2.parse(document.cookie);
    }
    function getRequestCookies(request) {
      if (typeof document === "undefined" || typeof location === "undefined") {
        return {};
      }
      switch (request.credentials) {
        case "same-origin": {
          return location.origin === request.url.origin ? getAllCookies() : {};
        }
        case "include": {
          return getAllCookies();
        }
        default: {
          return {};
        }
      }
    }
    var import_headers_polyfill3 = require_lib3();
    function parseContentHeaders(headersString) {
      var _a, _b;
      const headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);
      const contentType = headers.get("content-type") || "text/plain";
      const disposition = headers.get("content-disposition");
      if (!disposition) {
        throw new Error('"Content-Disposition" header is required.');
      }
      const directives = disposition.split(";").reduce((acc, chunk) => {
        const [name2, ...rest2] = chunk.trim().split("=");
        acc[name2] = rest2.join("=");
        return acc;
      }, {});
      const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);
      const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);
      return {
        name,
        filename,
        contentType
      };
    }
    function parseMultipartData(data2, headers) {
      const contentType = headers == null ? void 0 : headers.get("content-type");
      if (!contentType) {
        return void 0;
      }
      const [, ...directives] = contentType.split(/; */);
      const boundary = directives.filter((d) => d.startsWith("boundary=")).map((s) => s.replace(/^boundary=/, ""))[0];
      if (!boundary) {
        return void 0;
      }
      const boundaryRegExp = new RegExp(`--+${boundary}`);
      const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith("\r\n") && chunk.endsWith("\r\n")).map((chunk) => chunk.trimStart().replace(/\r\n$/, ""));
      if (!fields.length) {
        return void 0;
      }
      const parsedBody = {};
      try {
        for (const field2 of fields) {
          const [contentHeaders, ...rest2] = field2.split("\r\n\r\n");
          const contentBody = rest2.join("\r\n\r\n");
          const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);
          const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });
          const parsedValue = parsedBody[name];
          if (parsedValue === void 0) {
            parsedBody[name] = value;
          } else if (Array.isArray(parsedValue)) {
            parsedBody[name] = [...parsedValue, value];
          } else {
            parsedBody[name] = [parsedValue, value];
          }
        }
        return parsedBody;
      } catch (error2) {
        return void 0;
      }
    }
    function parseBody(body2, headers) {
      var _a;
      if (!body2) {
        return body2;
      }
      const contentType = ((_a = headers == null ? void 0 : headers.get("content-type")) == null ? void 0 : _a.toLowerCase()) || "";
      const hasMultipartContent = contentType.startsWith("multipart/form-data");
      if (hasMultipartContent && typeof body2 !== "object") {
        return parseMultipartData(body2.toString(), headers) || body2;
      }
      const hasJsonContent = contentType.includes("json");
      if (hasJsonContent && typeof body2 !== "object") {
        return jsonParse(body2.toString()) || body2;
      }
      return body2;
    }
    function isStringEqual(actual, expected) {
      return actual.toLowerCase() === expected.toLowerCase();
    }
    var MockedRequest = class extends import_interceptors.IsomorphicRequest {
      constructor(url, init = {}) {
        super(url, init);
        if (init.id) {
          this.id = init.id;
        }
        this.cache = init.cache || "default";
        this.destination = init.destination || "";
        this.integrity = init.integrity || "";
        this.keepalive = init.keepalive || false;
        this.mode = init.mode || "cors";
        this.priority = init.priority || "auto";
        this.redirect = init.redirect || "follow";
        this.referrer = init.referrer || "";
        this.referrerPolicy = init.referrerPolicy || "no-referrer";
        this.cookies = init.cookies || this.getCookies();
      }
      get body() {
        const text2 = (0, import_bufferUtils.decodeBuffer)(this["_body"]);
        const body2 = parseBody(text2, this.headers);
        if (isStringEqual(this.method, "GET") && body2 === "") {
          return void 0;
        }
        return body2;
      }
      passthrough() {
        return {
          status: 101,
          statusText: "Continue",
          headers: new import_headers_polyfill4.Headers(),
          body: null,
          passthrough: true,
          once: false
        };
      }
      getCookies() {
        var _a;
        const requestCookiesString = this.headers.get("cookie");
        const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};
        import_cookies.store.hydrate();
        const cookiesFromStore = Array.from(
          (_a = import_cookies.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()
        ).reduce((cookies, [name, { value }]) => {
          return Object.assign(cookies, { [name.trim()]: value });
        }, {});
        const cookiesFromDocument = getRequestCookies(this);
        const forwardedCookies = {
          ...cookiesFromDocument,
          ...cookiesFromStore
        };
        for (const [name, value] of Object.entries(forwardedCookies)) {
          this.headers.append("cookie", `${name}=${value}`);
        }
        return {
          ...forwardedCookies,
          ...ownCookies
        };
      }
    };
    function parseWorkerRequest(rawRequest) {
      const url = new URL(rawRequest.url);
      const headers = new import_headers_polyfill5.Headers(rawRequest.headers);
      return new MockedRequest(url, {
        ...rawRequest,
        body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || ""),
        headers
      });
    }
    var import_until2 = require_lib2();
    var getResponse = async (request, handlers, resolutionContext) => {
      const relevantHandlers = handlers.filter((handler) => {
        return handler.test(request, resolutionContext);
      });
      if (relevantHandlers.length === 0) {
        return {
          handler: void 0,
          response: void 0
        };
      }
      const result = await relevantHandlers.reduce(async (executionResult, handler) => {
        const previousResults = await executionResult;
        if (!!(previousResults == null ? void 0 : previousResults.response)) {
          return executionResult;
        }
        const result2 = await handler.run(request, resolutionContext);
        if (result2 === null || result2.handler.shouldSkip) {
          return null;
        }
        if (!result2.response) {
          return {
            request: result2.request,
            handler: result2.handler,
            response: void 0,
            parsedResult: result2.parsedResult
          };
        }
        if (result2.response.once) {
          handler.markAsSkipped(true);
        }
        return result2;
      }, Promise.resolve(null));
      if (!result) {
        return {
          handler: void 0,
          response: void 0
        };
      }
      return {
        handler: result.handler,
        publicRequest: result.request,
        parsedRequest: result.parsedResult,
        response: result.response
      };
    };
    var import_js_levenshtein = __toESM(require_js_levenshtein());
    var import_graphql = (init_graphql(), __toCommonJS(graphql_exports));
    var getPublicUrlFromRequest = (request) => {
      return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(
        request.url.pathname,
        `${request.url.protocol}//${request.url.host}`
      ).href;
    };
    function parseDocumentNode(node) {
      var _a;
      const operationDef = node.definitions.find((def) => {
        return def.kind === "OperationDefinition";
      });
      return {
        operationType: operationDef == null ? void 0 : operationDef.operation,
        operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value
      };
    }
    function parseQuery(query) {
      try {
        const ast = (0, import_graphql.parse)(query);
        return parseDocumentNode(ast);
      } catch (error2) {
        return error2;
      }
    }
    function extractMultipartVariables(variables, map, files) {
      const operations = { variables };
      for (const [key, pathArray] of Object.entries(map)) {
        if (!(key in files)) {
          throw new Error(`Given files do not have a key '${key}' .`);
        }
        for (const dotPath of pathArray) {
          const [lastPath, ...reversedPaths] = dotPath.split(".").reverse();
          const paths = reversedPaths.reverse();
          let target = operations;
          for (const path of paths) {
            if (!(path in target)) {
              throw new Error(`Property '${paths}' is not in operations.`);
            }
            target = target[path];
          }
          target[lastPath] = files[key];
        }
      }
      return operations.variables;
    }
    function getGraphQLInput(request) {
      var _a, _b;
      switch (request.method) {
        case "GET": {
          const query = request.url.searchParams.get("query");
          const variables = request.url.searchParams.get("variables") || "";
          return {
            query,
            variables: jsonParse(variables)
          };
        }
        case "POST": {
          if ((_a = request.body) == null ? void 0 : _a.query) {
            const { query, variables } = request.body;
            return {
              query,
              variables
            };
          }
          if ((_b = request.body) == null ? void 0 : _b.operations) {
            const { operations, map, ...files } = request.body;
            const parsedOperations = jsonParse(
              operations
            ) || {};
            if (!parsedOperations.query) {
              return null;
            }
            const parsedMap = jsonParse(map || "") || {};
            const variables = parsedOperations.variables ? extractMultipartVariables(
              parsedOperations.variables,
              parsedMap,
              files
            ) : {};
            return {
              query: parsedOperations.query,
              variables
            };
          }
        }
        default:
          return null;
      }
    }
    function parseGraphQLRequest(request) {
      const input = getGraphQLInput(request);
      if (!input || !input.query) {
        return void 0;
      }
      const { query, variables } = input;
      const parsedResult = parseQuery(query);
      if (parsedResult instanceof Error) {
        const requestPublicUrl = getPublicUrlFromRequest(request);
        throw new Error(
          devUtils.formatMessage(
            'Failed to intercept a GraphQL request to "%s %s": cannot parse query. See the error message from the parser below.\n\n%s',
            request.method,
            requestPublicUrl,
            parsedResult.message
          )
        );
      }
      return {
        operationType: parsedResult.operationType,
        operationName: parsedResult.operationName,
        variables
      };
    }
    function getStatusCodeColor(status2) {
      if (status2 < 300) {
        return "#69AB32";
      }
      if (status2 < 400) {
        return "#F0BB4B";
      }
      return "#E95F5D";
    }
    function getTimestamp() {
      const now = /* @__PURE__ */ new Date();
      return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, "0")).join(":");
    }
    function prepareRequest(request) {
      return {
        ...request,
        body: request.body,
        headers: request.headers.all()
      };
    }
    var import_headers_polyfill6 = require_lib3();
    function prepareResponse(res) {
      const responseHeaders = (0, import_headers_polyfill6.objectToHeaders)(res.headers);
      const parsedBody = parseBody(res.body, responseHeaders);
      return {
        ...res,
        body: parsedBody
      };
    }
    var import_path_to_regexp = (init_dist(), __toCommonJS(dist_exports));
    var import_getCleanUrl = require_getCleanUrl();
    var REDUNDANT_CHARACTERS_EXP = /[\?|#].*$/g;
    function getSearchParams(path) {
      return new URL(`/${path}`, "http://localhost").searchParams;
    }
    function cleanUrl(path) {
      return path.replace(REDUNDANT_CHARACTERS_EXP, "");
    }
    function isAbsoluteUrl(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    }
    function getAbsoluteUrl(path, baseUrl) {
      if (isAbsoluteUrl(path)) {
        return path;
      }
      if (path.startsWith("*")) {
        return path;
      }
      const origin = baseUrl || typeof document !== "undefined" && document.baseURI;
      return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;
    }
    function normalizePath(path, baseUrl) {
      if (path instanceof RegExp) {
        return path;
      }
      const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);
      return cleanUrl(maybeAbsoluteUrl);
    }
    function coercePath(path) {
      return path.replace(
        /([:a-zA-Z_-]*)(\*{1,2})+/g,
        (_, parameterName, wildcard) => {
          const expression = "(.*)";
          if (!parameterName) {
            return expression;
          }
          return parameterName.startsWith(":") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;
        }
      ).replace(/([^\/])(:)(?=\d+)/, "$1\\$2").replace(/^([^\/]+)(:)(?=\/\/)/, "$1\\$2");
    }
    function matchRequestUrl(url, path, baseUrl) {
      const normalizedPath = normalizePath(path, baseUrl);
      const cleanPath = typeof normalizedPath === "string" ? coercePath(normalizedPath) : normalizedPath;
      const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);
      const result = (0, import_path_to_regexp.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);
      const params = result && result.params || {};
      return {
        matches: result !== false,
        params
      };
    }
    var import_headers_polyfill8 = require_lib3();
    var import_headers_polyfill7 = require_lib3();
    function compose(...fns) {
      return (...args) => {
        return fns.reduceRight((leftFn, rightFn) => {
          return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);
        }, args[0]);
      };
    }
    var defaultResponse = {
      status: 200,
      statusText: "OK",
      body: null,
      delay: 0,
      once: false,
      passthrough: false
    };
    var defaultResponseTransformers = [];
    function createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {
      return async (...transformers) => {
        const initialResponse = Object.assign(
          {},
          defaultResponse,
          {
            headers: new import_headers_polyfill7.Headers({
              "x-powered-by": "msw"
            })
          },
          responseOverrides
        );
        const resolvedTransformers = [
          ...defaultTransformers,
          ...transformers
        ].filter(Boolean);
        const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;
        return resolvedResponse;
      };
    }
    var response = Object.assign(createResponseComposition(), {
      once: createResponseComposition({ once: true }),
      networkError(message) {
        throw new NetworkError(message);
      }
    });
    var SOURCE_FRAME = /[\/\\]msw[\/\\]src[\/\\](.+)/;
    var BUILD_FRAME = /(node_modules)?[\/\\]lib[\/\\](umd|esm|iief|cjs)[\/\\]|^[^\/\\]*$/;
    function getCallFrame(error2) {
      const stack = error2.stack;
      if (!stack) {
        return;
      }
      const frames = stack.split("\n").slice(1);
      const declarationFrame = frames.find((frame) => {
        return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));
      });
      if (!declarationFrame) {
        return;
      }
      const declarationPath = declarationFrame.replace(/\s*at [^()]*\(([^)]+)\)/, "$1").replace(/^@/, "");
      return declarationPath;
    }
    function isIterable(fn) {
      if (!fn) {
        return false;
      }
      return typeof fn[Symbol.iterator] == "function";
    }
    var defaultContext = {
      status,
      set,
      delay,
      fetch
    };
    var RequestHandler = class {
      constructor(options) {
        this.shouldSkip = false;
        this.ctx = options.ctx || defaultContext;
        this.resolver = options.resolver;
        const callFrame = getCallFrame(new Error());
        this.info = {
          ...options.info,
          callFrame
        };
      }
      parse(_request, _resolutionContext) {
        return null;
      }
      test(request, resolutionContext) {
        return this.predicate(
          request,
          this.parse(request, resolutionContext),
          resolutionContext
        );
      }
      getPublicRequest(request, _parsedResult) {
        return request;
      }
      markAsSkipped(shouldSkip = true) {
        this.shouldSkip = shouldSkip;
      }
      async run(request, resolutionContext) {
        if (this.shouldSkip) {
          return null;
        }
        const parsedResult = this.parse(request, resolutionContext);
        const shouldIntercept = this.predicate(
          request,
          parsedResult,
          resolutionContext
        );
        if (!shouldIntercept) {
          return null;
        }
        const publicRequest = this.getPublicRequest(request, parsedResult);
        const executeResolver = this.wrapResolver(this.resolver);
        const mockedResponse = await executeResolver(
          publicRequest,
          response,
          this.ctx
        );
        return this.createExecutionResult(
          parsedResult,
          publicRequest,
          mockedResponse
        );
      }
      wrapResolver(resolver) {
        return async (req, res, ctx) => {
          const result = this.resolverGenerator || await resolver(req, res, ctx);
          if (isIterable(result)) {
            const { value, done } = result[Symbol.iterator]().next();
            const nextResponse = await value;
            if (!nextResponse && done) {
              return this.resolverGeneratorResult;
            }
            if (!this.resolverGenerator) {
              this.resolverGenerator = result;
            }
            this.resolverGeneratorResult = nextResponse;
            return nextResponse;
          }
          return result;
        };
      }
      createExecutionResult(parsedResult, request, response2) {
        return {
          handler: this,
          parsedResult: parsedResult || null,
          request,
          response: response2 || null
        };
      }
    };
    var RESTMethods = ((RESTMethods2) => {
      RESTMethods2["HEAD"] = "HEAD";
      RESTMethods2["GET"] = "GET";
      RESTMethods2["POST"] = "POST";
      RESTMethods2["PUT"] = "PUT";
      RESTMethods2["PATCH"] = "PATCH";
      RESTMethods2["OPTIONS"] = "OPTIONS";
      RESTMethods2["DELETE"] = "DELETE";
      return RESTMethods2;
    })(RESTMethods || {});
    var restContext = {
      ...defaultContext,
      cookie,
      body,
      text,
      json,
      xml
    };
    var RestRequest = class extends MockedRequest {
      constructor(request, params) {
        super(request.url, {
          ...request,
          body: request["_body"]
        });
        this.params = params;
        this.id = request.id;
      }
    };
    var RestHandler = class extends RequestHandler {
      constructor(method, path, resolver) {
        super({
          info: {
            header: `${method} ${path}`,
            path,
            method
          },
          ctx: restContext,
          resolver
        });
        this.checkRedundantQueryParameters();
      }
      checkRedundantQueryParameters() {
        const { method, path } = this.info;
        if (path instanceof RegExp) {
          return;
        }
        const url = cleanUrl(path);
        if (url === path) {
          return;
        }
        const searchParams = getSearchParams(path);
        const queryParams = [];
        searchParams.forEach((_, paramName) => {
          queryParams.push(paramName);
        });
        devUtils.warn(
          `Found a redundant usage of query parameters in the request handler URL for "${method} ${path}". Please match against a path instead and access query parameters in the response resolver function using "req.url.searchParams".`
        );
      }
      parse(request, resolutionContext) {
        return matchRequestUrl(
          request.url,
          this.info.path,
          resolutionContext == null ? void 0 : resolutionContext.baseUrl
        );
      }
      getPublicRequest(request, parsedResult) {
        return new RestRequest(request, parsedResult.params || {});
      }
      predicate(request, parsedResult) {
        const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);
        return matchesMethod && parsedResult.matches;
      }
      log(request, response2) {
        const publicUrl = getPublicUrlFromRequest(request);
        const loggedRequest = prepareRequest(request);
        const loggedResponse = prepareResponse(response2);
        const statusColor = getStatusCodeColor(response2.status);
        console.groupCollapsed(
          devUtils.formatMessage("%s %s %s (%c%s%c)"),
          getTimestamp(),
          request.method,
          publicUrl,
          `color:${statusColor}`,
          `${response2.status} ${response2.statusText}`,
          "color:inherit"
        );
        console.log("Request", loggedRequest);
        console.log("Handler:", this);
        console.log("Response", loggedResponse);
        console.groupEnd();
      }
    };
    var import_outvariant3 = require_lib();
    var field = (fieldName, fieldValue) => {
      return (res) => {
        validateFieldName(fieldName);
        const prevBody = jsonParse(res.body) || {};
        const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });
        return json(nextBody)(res);
      };
    };
    function validateFieldName(fieldName) {
      (0, import_outvariant3.invariant)(
        fieldName.trim() !== "",
        devUtils.formatMessage(
          "Failed to set a custom field on a GraphQL response: field name cannot be empty."
        )
      );
      (0, import_outvariant3.invariant)(
        fieldName !== "data",
        devUtils.formatMessage(
          'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.data()" instead?',
          fieldName
        )
      );
      (0, import_outvariant3.invariant)(
        fieldName !== "errors",
        devUtils.formatMessage(
          'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.errors()" instead?',
          fieldName
        )
      );
      (0, import_outvariant3.invariant)(
        fieldName !== "extensions",
        devUtils.formatMessage(
          'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.extensions()" instead?',
          fieldName
        )
      );
    }
    function tryCatch(fn, onException) {
      try {
        const result = fn();
        return result;
      } catch (error2) {
        onException == null ? void 0 : onException(error2);
      }
    }
    var graphqlContext = {
      ...defaultContext,
      data,
      extensions,
      errors,
      cookie,
      field
    };
    function isDocumentNode(value) {
      if (value == null) {
        return false;
      }
      return typeof value === "object" && "kind" in value && "definitions" in value;
    }
    var GraphQLRequest = class extends MockedRequest {
      constructor(request, variables, operationName) {
        super(request.url, {
          ...request,
          body: request["_body"]
        });
        this.variables = variables;
        this.operationName = operationName;
      }
    };
    var GraphQLHandler = class extends RequestHandler {
      constructor(operationType, operationName, endpoint, resolver) {
        let resolvedOperationName = operationName;
        if (isDocumentNode(operationName)) {
          const parsedNode = parseDocumentNode(operationName);
          if (parsedNode.operationType !== operationType) {
            throw new Error(
              `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected "${operationType}", but got "${parsedNode.operationType}").`
            );
          }
          if (!parsedNode.operationName) {
            throw new Error(
              `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`
            );
          }
          resolvedOperationName = parsedNode.operationName;
        }
        const header = operationType === "all" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;
        super({
          info: {
            header,
            operationType,
            operationName: resolvedOperationName
          },
          ctx: graphqlContext,
          resolver
        });
        this.endpoint = endpoint;
      }
      parse(request) {
        return tryCatch(
          () => parseGraphQLRequest(request),
          (error2) => console.error(error2.message)
        );
      }
      getPublicRequest(request, parsedResult) {
        var _a, _b;
        return new GraphQLRequest(
          request,
          (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},
          (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : ""
        );
      }
      predicate(request, parsedResult) {
        if (!parsedResult) {
          return false;
        }
        if (!parsedResult.operationName && this.info.operationType !== "all") {
          const publicUrl = getPublicUrlFromRequest(request);
          devUtils.warn(`Failed to intercept a GraphQL request at "${request.method} ${publicUrl}": anonymous GraphQL operations are not supported.

Consider naming this operation or using "graphql.operation()" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);
          return false;
        }
        const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);
        const hasMatchingOperationType = this.info.operationType === "all" || parsedResult.operationType === this.info.operationType;
        const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || "") : parsedResult.operationName === this.info.operationName;
        return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;
      }
      log(request, response2, parsedRequest) {
        const loggedRequest = prepareRequest(request);
        const loggedResponse = prepareResponse(response2);
        const statusColor = getStatusCodeColor(response2.status);
        const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;
        console.groupCollapsed(
          devUtils.formatMessage("%s %s (%c%s%c)"),
          getTimestamp(),
          `${requestInfo}`,
          `color:${statusColor}`,
          `${response2.status} ${response2.statusText}`,
          "color:inherit"
        );
        console.log("Request:", loggedRequest);
        console.log("Handler:", this);
        console.log("Response:", loggedResponse);
        console.groupEnd();
      }
    };
    var MAX_MATCH_SCORE = 3;
    var MAX_SUGGESTION_COUNT = 4;
    var TYPE_MATCH_DELTA = 0.5;
    function groupHandlersByType(handlers) {
      return handlers.reduce(
        (groups, handler) => {
          if (handler instanceof RestHandler) {
            groups.rest.push(handler);
          }
          if (handler instanceof GraphQLHandler) {
            groups.graphql.push(handler);
          }
          return groups;
        },
        {
          rest: [],
          graphql: []
        }
      );
    }
    function getRestHandlerScore() {
      return (request, handler) => {
        const { path, method } = handler.info;
        if (path instanceof RegExp || method instanceof RegExp) {
          return Infinity;
        }
        const hasSameMethod = isStringEqual(request.method, method);
        const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;
        const requestPublicUrl = getPublicUrlFromRequest(request);
        const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);
        return score - methodScoreDelta;
      };
    }
    function getGraphQLHandlerScore(parsedQuery) {
      return (_, handler) => {
        if (typeof parsedQuery.operationName === "undefined") {
          return Infinity;
        }
        const { operationType, operationName } = handler.info;
        if (typeof operationName !== "string") {
          return Infinity;
        }
        const hasSameOperationType = parsedQuery.operationType === operationType;
        const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;
        const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);
        return score - operationTypeScoreDelta;
      };
    }
    function getSuggestedHandler(request, handlers, getScore) {
      const suggestedHandlers = handlers.reduce((suggestions, handler) => {
        const score = getScore(request, handler);
        return suggestions.concat([[score, handler]]);
      }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);
      return suggestedHandlers;
    }
    function getSuggestedHandlersMessage(handlers) {
      if (handlers.length > 1) {
        return `Did you mean to request one of the following resources instead?

${handlers.map((handler) => `  • ${handler.info.header}`).join("\n")}`;
      }
      return `Did you mean to request "${handlers[0].info.header}" instead?`;
    }
    function onUnhandledRequest(request, handlers, strategy = "warn") {
      const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));
      function generateHandlerSuggestion() {
        const handlerGroups = groupHandlersByType(handlers);
        const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;
        const suggestedHandlers = getSuggestedHandler(
          request,
          relevantHandlers,
          parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()
        );
        return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : "";
      }
      function generateUnhandledRequestMessage() {
        const publicUrl = getPublicUrlFromRequest(request);
        const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;
        const handlerSuggestion = generateHandlerSuggestion();
        const messageTemplate = [
          `captured a request without a matching request handler:`,
          `  • ${requestHeader}`,
          handlerSuggestion,
          `If you still wish to intercept this unhandled request, please create a request handler for it.
Read more: https://mswjs.io/docs/getting-started/mocks`
        ].filter(Boolean);
        return messageTemplate.join("\n\n");
      }
      function applyStrategy(strategy2) {
        const message = generateUnhandledRequestMessage();
        switch (strategy2) {
          case "error": {
            devUtils.error("Error: %s", message);
            throw new Error(
              devUtils.formatMessage(
                'Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.'
              )
            );
          }
          case "warn": {
            devUtils.warn("Warning: %s", message);
            break;
          }
          case "bypass":
            break;
          default:
            throw new Error(
              devUtils.formatMessage(
                'Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.',
                strategy2
              )
            );
        }
      }
      if (typeof strategy === "function") {
        strategy(request, {
          warning: applyStrategy.bind(null, "warn"),
          error: applyStrategy.bind(null, "error")
        });
        return;
      }
      applyStrategy(strategy);
    }
    var import_cookies2 = require_lib6();
    function readResponseCookies(request, response2) {
      import_cookies2.store.add({ ...request, url: request.url.toString() }, response2);
      import_cookies2.store.persist();
    }
    async function handleRequest(request, handlers, options, emitter, handleRequestOptions) {
      var _a, _b, _c, _d, _e, _f;
      emitter.emit("request:start", request);
      if (request.headers.get("x-msw-bypass") === "true") {
        emitter.emit("request:end", request);
        (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);
        return;
      }
      const [lookupError, lookupResult] = await (0, import_until2.until)(() => {
        return getResponse(
          request,
          handlers,
          handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext
        );
      });
      if (lookupError) {
        emitter.emit("unhandledException", lookupError, request);
        throw lookupError;
      }
      const { handler, response: response2 } = lookupResult;
      if (!handler) {
        onUnhandledRequest(request, handlers, options.onUnhandledRequest);
        emitter.emit("request:unhandled", request);
        emitter.emit("request:end", request);
        (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);
        return;
      }
      if (!response2) {
        devUtils.warn(
          `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.

  • %s
    %s`,
          response2,
          handler.info.header,
          handler.info.callFrame
        );
        emitter.emit("request:end", request);
        (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);
        return;
      }
      if (response2.passthrough) {
        emitter.emit("request:end", request);
        (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);
        return;
      }
      readResponseCookies(request, response2);
      emitter.emit("request:match", request);
      const requiredLookupResult = lookupResult;
      const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;
      (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(
        handleRequestOptions,
        transformedResponse,
        requiredLookupResult
      );
      emitter.emit("request:end", request);
      return transformedResponse;
    }
    var import_headers_polyfill9 = require_lib3();
    async function serializeResponse(response2) {
      return {
        status: response2.status,
        statusText: response2.statusText,
        headers: (0, import_headers_polyfill9.flattenHeadersObject)((0, import_headers_polyfill9.headersToObject)(response2.headers)),
        body: await response2.clone().text()
      };
    }
    var createRequestListener = (context2, options) => {
      return async (event, message) => {
        var _a;
        const messageChannel = new WorkerChannel(event.ports[0]);
        const request = parseWorkerRequest(message.payload);
        try {
          await handleRequest(
            request,
            context2.requestHandlers,
            options,
            context2.emitter,
            {
              transformResponse,
              onPassthroughResponse() {
                messageChannel.postMessage("NOT_FOUND");
              },
              async onMockedResponse(response2, { handler, publicRequest, parsedRequest }) {
                if (response2.body instanceof ReadableStream) {
                  throw new Error(
                    devUtils.formatMessage(
                      'Failed to construct a mocked response with a "ReadableStream" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.'
                    )
                  );
                }
                const responseInstance = new Response(response2.body, response2);
                const responseForLogs = responseInstance.clone();
                const responseBodyBuffer = await responseInstance.arrayBuffer();
                const responseBody = response2.body == null ? null : responseBodyBuffer;
                messageChannel.postMessage(
                  "MOCK_RESPONSE",
                  {
                    ...response2,
                    body: responseBody
                  },
                  [responseBodyBuffer]
                );
                if (!options.quiet) {
                  context2.emitter.once("response:mocked", async () => {
                    handler.log(
                      publicRequest,
                      await serializeResponse(responseForLogs),
                      parsedRequest
                    );
                  });
                }
              }
            }
          );
        } catch (error2) {
          if (error2 instanceof NetworkError) {
            messageChannel.postMessage("NETWORK_ERROR", {
              name: error2.name,
              message: error2.message
            });
            return;
          }
          if (error2 instanceof Error) {
            devUtils.error(
              `Uncaught exception in the request handler for "%s %s":

%s

This exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,
              request.method,
              request.url,
              (_a = error2.stack) != null ? _a : error2
            );
            messageChannel.postMessage("MOCK_RESPONSE", {
              status: 500,
              statusText: "Request Handler Error",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                name: error2.name,
                message: error2.message,
                stack: error2.stack
              })
            });
          }
        }
      };
    };
    function transformResponse(response2) {
      return {
        status: response2.status,
        statusText: response2.statusText,
        headers: response2.headers.all(),
        body: response2.body,
        delay: response2.delay
      };
    }
    async function requestIntegrityCheck(context2, serviceWorker) {
      context2.workerChannel.send("INTEGRITY_CHECK_REQUEST");
      const { payload: actualChecksum } = await context2.events.once(
        "INTEGRITY_CHECK_RESPONSE"
      );
      if (actualChecksum !== "3d6b9f06410d179a7f7404d4bf4c3c70") {
        throw new Error(
          `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${"3d6b9f06410d179a7f7404d4bf4c3c70"}).`
        );
      }
      return serviceWorker;
    }
    var import_until3 = require_lib2();
    function deferNetworkRequestsUntil(predicatePromise) {
      const originalXhrSend = window.XMLHttpRequest.prototype.send;
      window.XMLHttpRequest.prototype.send = function(...args) {
        (0, import_until3.until)(() => predicatePromise).then(() => {
          window.XMLHttpRequest.prototype.send = originalXhrSend;
          this.send(...args);
        });
      };
      const originalFetch = window.fetch;
      window.fetch = async (...args) => {
        await (0, import_until3.until)(() => predicatePromise);
        window.fetch = originalFetch;
        return window.fetch(...args);
      };
    }
    function createResponseListener(context2) {
      return (_, message) => {
        var _a;
        const { payload: responseJson } = message;
        if ((_a = responseJson.type) == null ? void 0 : _a.includes("opaque")) {
          return;
        }
        const response2 = new Response(responseJson.body || null, responseJson);
        const isMockedResponse = response2.headers.get("x-powered-by") === "msw";
        if (isMockedResponse) {
          context2.emitter.emit("response:mocked", response2, responseJson.requestId);
        } else {
          context2.emitter.emit("response:bypass", response2, responseJson.requestId);
        }
      };
    }
    function validateWorkerScope(registration, options) {
      if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {
        devUtils.warn(
          `Cannot intercept requests on this page because it's outside of the worker's scope ("${registration.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.

- (Recommended) Register the worker at the root level ("/") of your application.
- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`
        );
      }
    }
    var createStartHandler = (context2) => {
      return function start(options, customOptions) {
        const startWorkerInstance = async () => {
          context2.events.removeAllListeners();
          context2.workerChannel.on(
            "REQUEST",
            createRequestListener(context2, options)
          );
          context2.workerChannel.on("RESPONSE", createResponseListener(context2));
          const instance = await getWorkerInstance(
            options.serviceWorker.url,
            options.serviceWorker.options,
            options.findWorker
          );
          const [worker, registration] = instance;
          if (!worker) {
            const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(
              `Failed to locate the Service Worker registration using a custom "findWorker" predicate.

Please ensure that the custom predicate properly locates the Service Worker registration at "%s".
More details: https://mswjs.io/docs/api/setup-worker/start#findworker
`,
              options.serviceWorker.url
            ) : devUtils.formatMessage(
              `Failed to locate the Service Worker registration.

This most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.

Please consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,
              options.serviceWorker.url,
              location.host
            );
            throw new Error(missingWorkerMessage);
          }
          context2.worker = worker;
          context2.registration = registration;
          context2.events.addListener(window, "beforeunload", () => {
            if (worker.state !== "redundant") {
              context2.workerChannel.send("CLIENT_CLOSED");
            }
            window.clearInterval(context2.keepAliveInterval);
          });
          const [integrityError] = await (0, import_until4.until)(
            () => requestIntegrityCheck(context2, worker)
          );
          if (integrityError) {
            devUtils.error(`Detected outdated Service Worker: ${integrityError.message}

The mocking is still enabled, but it's highly recommended that you update your Service Worker by running:

$ npx msw init <PUBLIC_DIR>

This is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.
If this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);
          }
          context2.keepAliveInterval = window.setInterval(
            () => context2.workerChannel.send("KEEPALIVE_REQUEST"),
            5e3
          );
          validateWorkerScope(registration, context2.startOptions);
          return registration;
        };
        const workerRegistration = startWorkerInstance().then(
          async (registration) => {
            const pendingInstance = registration.installing || registration.waiting;
            if (pendingInstance) {
              await new Promise((resolve) => {
                pendingInstance.addEventListener("statechange", () => {
                  if (pendingInstance.state === "activated") {
                    return resolve();
                  }
                });
              });
            }
            await enableMocking(context2, options).catch((error2) => {
              throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);
            });
            return registration;
          }
        );
        if (options.waitUntilReady) {
          deferNetworkRequestsUntil(workerRegistration);
        }
        return workerRegistration;
      };
    };
    function printStopMessage(args = {}) {
      if (args.quiet) {
        return;
      }
      console.log(
        `%c${devUtils.formatMessage("Mocking disabled.")}`,
        "color:orangered;font-weight:bold;"
      );
    }
    var createStop = (context2) => {
      return function stop() {
        var _a;
        if (!context2.isMockingEnabled) {
          devUtils.warn(
            'Found a redundant "worker.stop()" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this "worker.stop()" call.'
          );
          return;
        }
        context2.workerChannel.send("MOCK_DEACTIVATE");
        context2.isMockingEnabled = false;
        window.clearInterval(context2.keepAliveInterval);
        printStopMessage({ quiet: (_a = context2.startOptions) == null ? void 0 : _a.quiet });
      };
    };
    var DEFAULT_START_OPTIONS = {
      serviceWorker: {
        url: "/mockServiceWorker.js",
        options: null
      },
      quiet: false,
      waitUntilReady: true,
      onUnhandledRequest: "warn",
      findWorker(scriptURL, mockServiceWorkerUrl) {
        return scriptURL === mockServiceWorkerUrl;
      }
    };
    var import_interceptors3 = require_lib4();
    var import_fetch3 = require_fetch();
    var import_XMLHttpRequest = require_XMLHttpRequest();
    function createResponseFromIsomorphicResponse(response2) {
      return new Response(response2.body, {
        status: response2.status,
        statusText: response2.statusText,
        headers: response2.headers
      });
    }
    function createFallbackRequestListener(context2, options) {
      const interceptor = new import_interceptors3.BatchInterceptor({
        name: "fallback",
        interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]
      });
      interceptor.on("request", async (request) => {
        const mockedRequest = new MockedRequest(request.url, {
          ...request,
          body: await request.arrayBuffer()
        });
        const response2 = await handleRequest(
          mockedRequest,
          context2.requestHandlers,
          options,
          context2.emitter,
          {
            transformResponse(response3) {
              return {
                status: response3.status,
                statusText: response3.statusText,
                headers: response3.headers.all(),
                body: response3.body,
                delay: response3.delay
              };
            },
            onMockedResponse(_, { handler, publicRequest, parsedRequest }) {
              if (!options.quiet) {
                context2.emitter.once("response:mocked", async (response3) => {
                  handler.log(
                    publicRequest,
                    await serializeResponse(response3),
                    parsedRequest
                  );
                });
              }
            }
          }
        );
        if (response2) {
          request.respondWith(response2);
        }
      });
      interceptor.on("response", (request, response2) => {
        if (!request.id) {
          return;
        }
        const browserResponse = createResponseFromIsomorphicResponse(response2);
        if (response2.headers.get("x-powered-by") === "msw") {
          context2.emitter.emit("response:mocked", browserResponse, request.id);
        } else {
          context2.emitter.emit("response:bypass", browserResponse, request.id);
        }
      });
      interceptor.apply();
      return interceptor;
    }
    function createFallbackStart(context2) {
      return async function start(options) {
        context2.fallbackInterceptor = createFallbackRequestListener(
          context2,
          options
        );
        printStartMessage({
          message: "Mocking enabled (fallback mode).",
          quiet: options.quiet
        });
        return void 0;
      };
    }
    function createFallbackStop(context2) {
      return function stop() {
        var _a, _b;
        (_a = context2.fallbackInterceptor) == null ? void 0 : _a.dispose();
        printStopMessage({ quiet: (_b = context2.startOptions) == null ? void 0 : _b.quiet });
      };
    }
    var import_outvariant4 = require_lib();
    var import_strict_event_emitter = require_lib5();
    function pipeEvents(source, destination) {
      const rawEmit = source.emit;
      if (rawEmit._isPiped) {
        return;
      }
      source.emit = function(event, ...data2) {
        destination.emit(event, ...data2);
        return rawEmit.call(this, event, ...data2);
      };
      source.emit._isPiped = true;
    }
    function toReadonlyArray(source) {
      const clone = [...source];
      Object.freeze(clone);
      return clone;
    }
    var SetupApi = class {
      constructor(...initialHandlers) {
        this.validateHandlers(...initialHandlers);
        this.initialHandlers = toReadonlyArray(initialHandlers);
        this.currentHandlers = [...initialHandlers];
        this.emitter = new import_strict_event_emitter.Emitter();
        this.publicEmitter = new import_strict_event_emitter.Emitter();
        pipeEvents(this.emitter, this.publicEmitter);
        this.events = this.createLifeCycleEvents();
      }
      validateHandlers(...handlers) {
        for (const handler of handlers) {
          (0, import_outvariant4.invariant)(
            !Array.isArray(handler),
            devUtils.formatMessage(
              'Failed to construct "%s" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'
            ),
            this.constructor.name
          );
        }
      }
      dispose() {
        this.emitter.removeAllListeners();
        this.publicEmitter.removeAllListeners();
      }
      use(...runtimeHandlers) {
        this.currentHandlers.unshift(...runtimeHandlers);
      }
      restoreHandlers() {
        this.currentHandlers.forEach((handler) => {
          handler.markAsSkipped(false);
        });
      }
      resetHandlers(...nextHandlers) {
        this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];
      }
      listHandlers() {
        return toReadonlyArray(this.currentHandlers);
      }
      createLifeCycleEvents() {
        return {
          on: (...args) => {
            return this.publicEmitter.on(...args);
          },
          removeListener: (...args) => {
            return this.publicEmitter.removeListener(...args);
          },
          removeAllListeners: (...args) => {
            return this.publicEmitter.removeAllListeners(...args);
          }
        };
      }
    };
    var SetupWorkerApi = class extends SetupApi {
      constructor(...handlers) {
        super(...handlers);
        this.startHandler = null;
        this.stopHandler = null;
        (0, import_outvariant5.invariant)(
          !(0, import_is_node_process3.isNodeProcess)(),
          devUtils.formatMessage(
            "Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead."
          )
        );
        this.listeners = [];
        this.context = this.createWorkerContext();
      }
      createWorkerContext() {
        const context2 = {
          isMockingEnabled: false,
          startOptions: null,
          worker: null,
          registration: null,
          requestHandlers: this.currentHandlers,
          emitter: this.emitter,
          workerChannel: {
            on: (eventType, callback) => {
              this.context.events.addListener(
                navigator.serviceWorker,
                "message",
                (event) => {
                  if (event.source !== this.context.worker) {
                    return;
                  }
                  const message = event.data;
                  if (!message) {
                    return;
                  }
                  if (message.type === eventType) {
                    callback(event, message);
                  }
                }
              );
            },
            send: (type) => {
              var _a;
              (_a = this.context.worker) == null ? void 0 : _a.postMessage(type);
            }
          },
          events: {
            addListener: (target, eventType, callback) => {
              target.addEventListener(eventType, callback);
              this.listeners.push({ eventType, target, callback });
              return () => {
                target.removeEventListener(eventType, callback);
              };
            },
            removeAllListeners: () => {
              for (const { target, eventType, callback } of this.listeners) {
                target.removeEventListener(eventType, callback);
              }
              this.listeners = [];
            },
            once: (eventType) => {
              const bindings = [];
              return new Promise((resolve, reject) => {
                const handleIncomingMessage = (event) => {
                  try {
                    const message = event.data;
                    if (message.type === eventType) {
                      resolve(message);
                    }
                  } catch (error2) {
                    reject(error2);
                  }
                };
                bindings.push(
                  this.context.events.addListener(
                    navigator.serviceWorker,
                    "message",
                    handleIncomingMessage
                  ),
                  this.context.events.addListener(
                    navigator.serviceWorker,
                    "messageerror",
                    reject
                  )
                );
              }).finally(() => {
                bindings.forEach((unbind) => unbind());
              });
            }
          },
          useFallbackMode: !("serviceWorker" in navigator) || location.protocol === "file:"
        };
        Object.defineProperties(context2, {
          requestHandlers: {
            get: () => this.currentHandlers
          }
        });
        this.startHandler = context2.useFallbackMode ? createFallbackStart(context2) : createStartHandler(context2);
        this.stopHandler = context2.useFallbackMode ? createFallbackStop(context2) : createStop(context2);
        return context2;
      }
      async start(options = {}) {
        this.context.startOptions = mergeRight(
          DEFAULT_START_OPTIONS,
          options
        );
        return await this.startHandler(this.context.startOptions, options);
      }
      printHandlers() {
        const handlers = this.listHandlers();
        handlers.forEach((handler) => {
          const { header, callFrame } = handler.info;
          const pragma = handler.info.hasOwnProperty("operationType") ? "[graphql]" : "[rest]";
          console.groupCollapsed(`${pragma} ${header}`);
          if (callFrame) {
            console.log(`Declaration: ${callFrame}`);
          }
          console.log("Handler:", handler);
          console.groupEnd();
        });
      }
      stop() {
        super.dispose();
        this.context.events.removeAllListeners();
        this.context.emitter.removeAllListeners();
        this.stopHandler();
      }
    };
    function setupWorker(...handlers) {
      return new SetupWorkerApi(...handlers);
    }
    function createRestHandler(method) {
      return (path, resolver) => {
        return new RestHandler(method, path, resolver);
      };
    }
    var rest = {
      all: createRestHandler(/.+/),
      head: createRestHandler(
        "HEAD"
        /* HEAD */
      ),
      get: createRestHandler(
        "GET"
        /* GET */
      ),
      post: createRestHandler(
        "POST"
        /* POST */
      ),
      put: createRestHandler(
        "PUT"
        /* PUT */
      ),
      delete: createRestHandler(
        "DELETE"
        /* DELETE */
      ),
      patch: createRestHandler(
        "PATCH"
        /* PATCH */
      ),
      options: createRestHandler(
        "OPTIONS"
        /* OPTIONS */
      )
    };
    function createScopedGraphQLHandler(operationType, url) {
      return (operationName, resolver) => {
        return new GraphQLHandler(
          operationType,
          operationName,
          url,
          resolver
        );
      };
    }
    function createGraphQLOperationHandler(url) {
      return (resolver) => {
        return new GraphQLHandler(
          "all",
          new RegExp(".*"),
          url,
          resolver
        );
      };
    }
    var standardGraphQLHandlers = {
      operation: createGraphQLOperationHandler("*"),
      query: createScopedGraphQLHandler("query", "*"),
      mutation: createScopedGraphQLHandler("mutation", "*")
    };
    function createGraphQLLink(url) {
      return {
        operation: createGraphQLOperationHandler(url),
        query: createScopedGraphQLHandler("query", url),
        mutation: createScopedGraphQLHandler("mutation", url)
      };
    }
    var graphql = {
      ...standardGraphQLHandlers,
      link: createGraphQLLink
    };
    checkGlobals();
  }
});
export default require_lib8();
//# sourceMappingURL=msw.js.map
