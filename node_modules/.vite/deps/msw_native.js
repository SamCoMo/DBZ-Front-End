import {
  dist_exports,
  graphql_exports,
  init_dist,
  init_graphql,
  require_XMLHttpRequest,
  require_browser,
  require_bufferUtils,
  require_cookie,
  require_getCleanUrl,
  require_js_levenshtein,
  require_lib,
  require_lib2,
  require_lib3,
  require_lib4,
  require_lib5,
  require_lib6,
  require_lib7
} from "./chunk-YQBQLLLO.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-TIUEEL27.js";

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/supports-color/browser.js
var require_browser2 = __commonJS({
  "node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_browser2();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module.exports = chalk;
  }
});

// node_modules/msw/lib/native/index.js
var require_native = __commonJS({
  "node_modules/msw/lib/native/index.js"(exports, module) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var native_exports = {};
    __export(native_exports, {
      setupServer: () => setupServer
    });
    module.exports = __toCommonJS2(native_exports);
    var import_XMLHttpRequest = require_XMLHttpRequest();
    var import_chalk = __toESM(require_source());
    var import_outvariant4 = require_lib();
    var import_interceptors2 = require_lib4();
    var import_outvariant2 = require_lib();
    var import_strict_event_emitter = require_lib5();
    var import_outvariant = require_lib();
    var LIBRARY_PREFIX = "[MSW]";
    function formatMessage(message, ...positionals) {
      const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);
      return `${LIBRARY_PREFIX} ${interpolatedMessage}`;
    }
    function warn(message, ...positionals) {
      console.warn(formatMessage(message, ...positionals));
    }
    function error(message, ...positionals) {
      console.error(formatMessage(message, ...positionals));
    }
    var devUtils = {
      formatMessage,
      warn,
      error
    };
    function pipeEvents(source, destination) {
      const rawEmit = source.emit;
      if (rawEmit._isPiped) {
        return;
      }
      source.emit = function(event, ...data2) {
        destination.emit(event, ...data2);
        return rawEmit.call(this, event, ...data2);
      };
      source.emit._isPiped = true;
    }
    function toReadonlyArray(source) {
      const clone = [...source];
      Object.freeze(clone);
      return clone;
    }
    var SetupApi = class {
      constructor(...initialHandlers) {
        this.validateHandlers(...initialHandlers);
        this.initialHandlers = toReadonlyArray(initialHandlers);
        this.currentHandlers = [...initialHandlers];
        this.emitter = new import_strict_event_emitter.Emitter();
        this.publicEmitter = new import_strict_event_emitter.Emitter();
        pipeEvents(this.emitter, this.publicEmitter);
        this.events = this.createLifeCycleEvents();
      }
      validateHandlers(...handlers) {
        for (const handler of handlers) {
          (0, import_outvariant2.invariant)(
            !Array.isArray(handler),
            devUtils.formatMessage(
              'Failed to construct "%s" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'
            ),
            this.constructor.name
          );
        }
      }
      dispose() {
        this.emitter.removeAllListeners();
        this.publicEmitter.removeAllListeners();
      }
      use(...runtimeHandlers) {
        this.currentHandlers.unshift(...runtimeHandlers);
      }
      restoreHandlers() {
        this.currentHandlers.forEach((handler) => {
          handler.markAsSkipped(false);
        });
      }
      resetHandlers(...nextHandlers) {
        this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];
      }
      listHandlers() {
        return toReadonlyArray(this.currentHandlers);
      }
      createLifeCycleEvents() {
        return {
          on: (...args) => {
            return this.publicEmitter.on(...args);
          },
          removeListener: (...args) => {
            return this.publicEmitter.removeListener(...args);
          },
          removeAllListeners: (...args) => {
            return this.publicEmitter.removeAllListeners(...args);
          }
        };
      }
    };
    function isObject(value) {
      return value != null && typeof value === "object" && !Array.isArray(value);
    }
    function mergeRight(left, right) {
      return Object.entries(right).reduce((result, [key, rightValue]) => {
        const leftValue = result[key];
        if (Array.isArray(leftValue) && Array.isArray(rightValue)) {
          result[key] = leftValue.concat(rightValue);
          return result;
        }
        if (isObject(leftValue) && isObject(rightValue)) {
          result[key] = mergeRight(leftValue, rightValue);
          return result;
        }
        result[key] = rightValue;
        return result;
      }, Object.assign({}, left));
    }
    var cookieUtils2 = __toESM(require_cookie());
    var import_cookies = require_lib6();
    var import_interceptors = require_lib4();
    var import_bufferUtils = require_bufferUtils();
    var import_headers_polyfill2 = require_lib3();
    var cookieUtils = __toESM(require_cookie());
    function getAllCookies() {
      return cookieUtils.parse(document.cookie);
    }
    function getRequestCookies(request) {
      if (typeof document === "undefined" || typeof location === "undefined") {
        return {};
      }
      switch (request.credentials) {
        case "same-origin": {
          return location.origin === request.url.origin ? getAllCookies() : {};
        }
        case "include": {
          return getAllCookies();
        }
        default: {
          return {};
        }
      }
    }
    function jsonParse(value) {
      try {
        return JSON.parse(value);
      } catch (error2) {
        return void 0;
      }
    }
    var import_headers_polyfill = require_lib3();
    function parseContentHeaders(headersString) {
      var _a, _b;
      const headers = (0, import_headers_polyfill.stringToHeaders)(headersString);
      const contentType = headers.get("content-type") || "text/plain";
      const disposition = headers.get("content-disposition");
      if (!disposition) {
        throw new Error('"Content-Disposition" header is required.');
      }
      const directives = disposition.split(";").reduce((acc, chunk) => {
        const [name2, ...rest] = chunk.trim().split("=");
        acc[name2] = rest.join("=");
        return acc;
      }, {});
      const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);
      const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);
      return {
        name,
        filename,
        contentType
      };
    }
    function parseMultipartData(data2, headers) {
      const contentType = headers == null ? void 0 : headers.get("content-type");
      if (!contentType) {
        return void 0;
      }
      const [, ...directives] = contentType.split(/; */);
      const boundary = directives.filter((d) => d.startsWith("boundary=")).map((s) => s.replace(/^boundary=/, ""))[0];
      if (!boundary) {
        return void 0;
      }
      const boundaryRegExp = new RegExp(`--+${boundary}`);
      const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith("\r\n") && chunk.endsWith("\r\n")).map((chunk) => chunk.trimStart().replace(/\r\n$/, ""));
      if (!fields.length) {
        return void 0;
      }
      const parsedBody = {};
      try {
        for (const field2 of fields) {
          const [contentHeaders, ...rest] = field2.split("\r\n\r\n");
          const contentBody = rest.join("\r\n\r\n");
          const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);
          const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });
          const parsedValue = parsedBody[name];
          if (parsedValue === void 0) {
            parsedBody[name] = value;
          } else if (Array.isArray(parsedValue)) {
            parsedBody[name] = [...parsedValue, value];
          } else {
            parsedBody[name] = [parsedValue, value];
          }
        }
        return parsedBody;
      } catch (error2) {
        return void 0;
      }
    }
    function parseBody(body2, headers) {
      var _a;
      if (!body2) {
        return body2;
      }
      const contentType = ((_a = headers == null ? void 0 : headers.get("content-type")) == null ? void 0 : _a.toLowerCase()) || "";
      const hasMultipartContent = contentType.startsWith("multipart/form-data");
      if (hasMultipartContent && typeof body2 !== "object") {
        return parseMultipartData(body2.toString(), headers) || body2;
      }
      const hasJsonContent = contentType.includes("json");
      if (hasJsonContent && typeof body2 !== "object") {
        return jsonParse(body2.toString()) || body2;
      }
      return body2;
    }
    function isStringEqual(actual, expected) {
      return actual.toLowerCase() === expected.toLowerCase();
    }
    var MockedRequest = class extends import_interceptors.IsomorphicRequest {
      constructor(url, init = {}) {
        super(url, init);
        if (init.id) {
          this.id = init.id;
        }
        this.cache = init.cache || "default";
        this.destination = init.destination || "";
        this.integrity = init.integrity || "";
        this.keepalive = init.keepalive || false;
        this.mode = init.mode || "cors";
        this.priority = init.priority || "auto";
        this.redirect = init.redirect || "follow";
        this.referrer = init.referrer || "";
        this.referrerPolicy = init.referrerPolicy || "no-referrer";
        this.cookies = init.cookies || this.getCookies();
      }
      get body() {
        const text2 = (0, import_bufferUtils.decodeBuffer)(this["_body"]);
        const body2 = parseBody(text2, this.headers);
        if (isStringEqual(this.method, "GET") && body2 === "") {
          return void 0;
        }
        return body2;
      }
      passthrough() {
        return {
          status: 101,
          statusText: "Continue",
          headers: new import_headers_polyfill2.Headers(),
          body: null,
          passthrough: true,
          once: false
        };
      }
      getCookies() {
        var _a;
        const requestCookiesString = this.headers.get("cookie");
        const ownCookies = requestCookiesString ? cookieUtils2.parse(requestCookiesString) : {};
        import_cookies.store.hydrate();
        const cookiesFromStore = Array.from(
          (_a = import_cookies.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()
        ).reduce((cookies, [name, { value }]) => {
          return Object.assign(cookies, { [name.trim()]: value });
        }, {});
        const cookiesFromDocument = getRequestCookies(this);
        const forwardedCookies = {
          ...cookiesFromDocument,
          ...cookiesFromStore
        };
        for (const [name, value] of Object.entries(forwardedCookies)) {
          this.headers.append("cookie", `${name}=${value}`);
        }
        return {
          ...forwardedCookies,
          ...ownCookies
        };
      }
    };
    var import_until = require_lib2();
    var getResponse = async (request, handlers, resolutionContext) => {
      const relevantHandlers = handlers.filter((handler) => {
        return handler.test(request, resolutionContext);
      });
      if (relevantHandlers.length === 0) {
        return {
          handler: void 0,
          response: void 0
        };
      }
      const result = await relevantHandlers.reduce(async (executionResult, handler) => {
        const previousResults = await executionResult;
        if (!!(previousResults == null ? void 0 : previousResults.response)) {
          return executionResult;
        }
        const result2 = await handler.run(request, resolutionContext);
        if (result2 === null || result2.handler.shouldSkip) {
          return null;
        }
        if (!result2.response) {
          return {
            request: result2.request,
            handler: result2.handler,
            response: void 0,
            parsedResult: result2.parsedResult
          };
        }
        if (result2.response.once) {
          handler.markAsSkipped(true);
        }
        return result2;
      }, Promise.resolve(null));
      if (!result) {
        return {
          handler: void 0,
          response: void 0
        };
      }
      return {
        handler: result.handler,
        publicRequest: result.request,
        parsedRequest: result.parsedResult,
        response: result.response
      };
    };
    var import_js_levenshtein = __toESM(require_js_levenshtein());
    var import_graphql = (init_graphql(), __toCommonJS(graphql_exports));
    var getPublicUrlFromRequest = (request) => {
      return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(
        request.url.pathname,
        `${request.url.protocol}//${request.url.host}`
      ).href;
    };
    function parseDocumentNode(node) {
      var _a;
      const operationDef = node.definitions.find((def) => {
        return def.kind === "OperationDefinition";
      });
      return {
        operationType: operationDef == null ? void 0 : operationDef.operation,
        operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value
      };
    }
    function parseQuery(query) {
      try {
        const ast = (0, import_graphql.parse)(query);
        return parseDocumentNode(ast);
      } catch (error2) {
        return error2;
      }
    }
    function extractMultipartVariables(variables, map, files) {
      const operations = { variables };
      for (const [key, pathArray] of Object.entries(map)) {
        if (!(key in files)) {
          throw new Error(`Given files do not have a key '${key}' .`);
        }
        for (const dotPath of pathArray) {
          const [lastPath, ...reversedPaths] = dotPath.split(".").reverse();
          const paths = reversedPaths.reverse();
          let target = operations;
          for (const path of paths) {
            if (!(path in target)) {
              throw new Error(`Property '${paths}' is not in operations.`);
            }
            target = target[path];
          }
          target[lastPath] = files[key];
        }
      }
      return operations.variables;
    }
    function getGraphQLInput(request) {
      var _a, _b;
      switch (request.method) {
        case "GET": {
          const query = request.url.searchParams.get("query");
          const variables = request.url.searchParams.get("variables") || "";
          return {
            query,
            variables: jsonParse(variables)
          };
        }
        case "POST": {
          if ((_a = request.body) == null ? void 0 : _a.query) {
            const { query, variables } = request.body;
            return {
              query,
              variables
            };
          }
          if ((_b = request.body) == null ? void 0 : _b.operations) {
            const { operations, map, ...files } = request.body;
            const parsedOperations = jsonParse(
              operations
            ) || {};
            if (!parsedOperations.query) {
              return null;
            }
            const parsedMap = jsonParse(map || "") || {};
            const variables = parsedOperations.variables ? extractMultipartVariables(
              parsedOperations.variables,
              parsedMap,
              files
            ) : {};
            return {
              query: parsedOperations.query,
              variables
            };
          }
        }
        default:
          return null;
      }
    }
    function parseGraphQLRequest(request) {
      const input = getGraphQLInput(request);
      if (!input || !input.query) {
        return void 0;
      }
      const { query, variables } = input;
      const parsedResult = parseQuery(query);
      if (parsedResult instanceof Error) {
        const requestPublicUrl = getPublicUrlFromRequest(request);
        throw new Error(
          devUtils.formatMessage(
            'Failed to intercept a GraphQL request to "%s %s": cannot parse query. See the error message from the parser below.\n\n%s',
            request.method,
            requestPublicUrl,
            parsedResult.message
          )
        );
      }
      return {
        operationType: parsedResult.operationType,
        operationName: parsedResult.operationName,
        variables
      };
    }
    var codes_default = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    var status = (statusCode, statusText) => {
      return (res) => {
        res.status = statusCode;
        res.statusText = statusText || codes_default[String(statusCode)];
        return res;
      };
    };
    var import_headers_polyfill3 = require_lib3();
    function set(...args) {
      return (res) => {
        const [name, value] = args;
        if (typeof name === "string") {
          res.headers.append(name, value);
        } else {
          const headers = (0, import_headers_polyfill3.objectToHeaders)(name);
          headers.forEach((value2, name2) => {
            res.headers.append(name2, value2);
          });
        }
        return res;
      };
    }
    var cookieUtils3 = __toESM(require_cookie());
    var cookie = (name, value, options) => {
      return (res) => {
        const serializedCookie = cookieUtils3.serialize(name, value, options);
        res.headers.append("Set-Cookie", serializedCookie);
        if (typeof document !== "undefined") {
          document.cookie = serializedCookie;
        }
        return res;
      };
    };
    var body = (value) => {
      return (res) => {
        res.body = value;
        return res;
      };
    };
    var json = (body2) => {
      return (res) => {
        res.headers.set("Content-Type", "application/json");
        res.body = JSON.stringify(body2);
        return res;
      };
    };
    var data = (payload) => {
      return (res) => {
        const prevBody = jsonParse(res.body) || {};
        const nextBody = mergeRight(prevBody, { data: payload });
        return json(nextBody)(res);
      };
    };
    var extensions = (payload) => {
      return (res) => {
        const prevBody = jsonParse(res.body) || {};
        const nextBody = mergeRight(prevBody, { extensions: payload });
        return json(nextBody)(res);
      };
    };
    var import_is_node_process = require_lib7();
    var SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;
    var MIN_SERVER_RESPONSE_TIME = 100;
    var MAX_SERVER_RESPONSE_TIME = 400;
    var NODE_SERVER_RESPONSE_TIME = 5;
    var getRandomServerResponseTime = () => {
      if ((0, import_is_node_process.isNodeProcess)()) {
        return NODE_SERVER_RESPONSE_TIME;
      }
      return Math.floor(
        Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME
      );
    };
    var delay = (durationOrMode) => {
      return (res) => {
        let delayTime;
        if (typeof durationOrMode === "string") {
          switch (durationOrMode) {
            case "infinite": {
              delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;
              break;
            }
            case "real": {
              delayTime = getRandomServerResponseTime();
              break;
            }
            default: {
              throw new Error(
                `Failed to delay a response: unknown delay mode "${durationOrMode}". Please make sure you provide one of the supported modes ("real", "infinite") or a number to "ctx.delay".`
              );
            }
          }
        } else if (typeof durationOrMode === "undefined") {
          delayTime = getRandomServerResponseTime();
        } else {
          if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {
            throw new Error(
              `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for "setTimeout" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the "infinite" delay mode to delay the response indefinitely.`
            );
          }
          delayTime = durationOrMode;
        }
        res.delay = delayTime;
        return res;
      };
    };
    var errors = (errorsList) => {
      return (res) => {
        if (errorsList == null) {
          return res;
        }
        const prevBody = jsonParse(res.body) || {};
        const nextBody = mergeRight(prevBody, { errors: errorsList });
        return json(nextBody)(res);
      };
    };
    var import_is_node_process2 = require_lib7();
    var import_headers_polyfill4 = require_lib3();
    var useFetch = (0, import_is_node_process2.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(require_browser())).then(
      ({ default: nodeFetch }) => nodeFetch(input, init)
    ) : globalThis.fetch;
    var augmentRequestInit = (requestInit) => {
      const headers = new import_headers_polyfill4.Headers(requestInit.headers);
      headers.set("x-msw-bypass", "true");
      return {
        ...requestInit,
        headers: headers.all()
      };
    };
    var createFetchRequestParameters = (input) => {
      const { body: body2, method } = input;
      const requestParameters = {
        ...input,
        body: void 0
      };
      if (["GET", "HEAD"].includes(method)) {
        return requestParameters;
      }
      if (typeof body2 === "object" || typeof body2 === "number" || typeof body2 === "boolean") {
        requestParameters.body = JSON.stringify(body2);
      } else {
        requestParameters.body = body2;
      }
      return requestParameters;
    };
    var fetch = (input, requestInit = {}) => {
      if (typeof input === "string") {
        return useFetch(input, augmentRequestInit(requestInit));
      }
      const requestParameters = createFetchRequestParameters(input);
      const derivedRequestInit = augmentRequestInit(requestParameters);
      return useFetch(input.url.href, derivedRequestInit);
    };
    var text = (body2) => {
      return (res) => {
        res.headers.set("Content-Type", "text/plain");
        res.body = body2;
        return res;
      };
    };
    var xml = (body2) => {
      return (res) => {
        res.headers.set("Content-Type", "text/xml");
        res.body = body2;
        return res;
      };
    };
    function getStatusCodeColor(status2) {
      if (status2 < 300) {
        return "#69AB32";
      }
      if (status2 < 400) {
        return "#F0BB4B";
      }
      return "#E95F5D";
    }
    function getTimestamp() {
      const now = /* @__PURE__ */ new Date();
      return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, "0")).join(":");
    }
    function prepareRequest(request) {
      return {
        ...request,
        body: request.body,
        headers: request.headers.all()
      };
    }
    var import_headers_polyfill5 = require_lib3();
    function prepareResponse(res) {
      const responseHeaders = (0, import_headers_polyfill5.objectToHeaders)(res.headers);
      const parsedBody = parseBody(res.body, responseHeaders);
      return {
        ...res,
        body: parsedBody
      };
    }
    var import_path_to_regexp = (init_dist(), __toCommonJS(dist_exports));
    var import_getCleanUrl = require_getCleanUrl();
    var REDUNDANT_CHARACTERS_EXP = /[\?|#].*$/g;
    function getSearchParams(path) {
      return new URL(`/${path}`, "http://localhost").searchParams;
    }
    function cleanUrl(path) {
      return path.replace(REDUNDANT_CHARACTERS_EXP, "");
    }
    function isAbsoluteUrl(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    }
    function getAbsoluteUrl(path, baseUrl) {
      if (isAbsoluteUrl(path)) {
        return path;
      }
      if (path.startsWith("*")) {
        return path;
      }
      const origin = baseUrl || typeof document !== "undefined" && document.baseURI;
      return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;
    }
    function normalizePath(path, baseUrl) {
      if (path instanceof RegExp) {
        return path;
      }
      const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);
      return cleanUrl(maybeAbsoluteUrl);
    }
    function coercePath(path) {
      return path.replace(
        /([:a-zA-Z_-]*)(\*{1,2})+/g,
        (_, parameterName, wildcard) => {
          const expression = "(.*)";
          if (!parameterName) {
            return expression;
          }
          return parameterName.startsWith(":") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;
        }
      ).replace(/([^\/])(:)(?=\d+)/, "$1\\$2").replace(/^([^\/]+)(:)(?=\/\/)/, "$1\\$2");
    }
    function matchRequestUrl(url, path, baseUrl) {
      const normalizedPath = normalizePath(path, baseUrl);
      const cleanPath = typeof normalizedPath === "string" ? coercePath(normalizedPath) : normalizedPath;
      const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);
      const result = (0, import_path_to_regexp.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);
      const params = result && result.params || {};
      return {
        matches: result !== false,
        params
      };
    }
    var import_headers_polyfill7 = require_lib3();
    var import_headers_polyfill6 = require_lib3();
    function compose(...fns) {
      return (...args) => {
        return fns.reduceRight((leftFn, rightFn) => {
          return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);
        }, args[0]);
      };
    }
    var NetworkError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "NetworkError";
      }
    };
    var defaultResponse = {
      status: 200,
      statusText: "OK",
      body: null,
      delay: 0,
      once: false,
      passthrough: false
    };
    var defaultResponseTransformers = [];
    function createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {
      return async (...transformers) => {
        const initialResponse = Object.assign(
          {},
          defaultResponse,
          {
            headers: new import_headers_polyfill6.Headers({
              "x-powered-by": "msw"
            })
          },
          responseOverrides
        );
        const resolvedTransformers = [
          ...defaultTransformers,
          ...transformers
        ].filter(Boolean);
        const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;
        return resolvedResponse;
      };
    }
    var response = Object.assign(createResponseComposition(), {
      once: createResponseComposition({ once: true }),
      networkError(message) {
        throw new NetworkError(message);
      }
    });
    var SOURCE_FRAME = /[\/\\]msw[\/\\]src[\/\\](.+)/;
    var BUILD_FRAME = /(node_modules)?[\/\\]lib[\/\\](umd|esm|iief|cjs)[\/\\]|^[^\/\\]*$/;
    function getCallFrame(error2) {
      const stack = error2.stack;
      if (!stack) {
        return;
      }
      const frames = stack.split("\n").slice(1);
      const declarationFrame = frames.find((frame) => {
        return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));
      });
      if (!declarationFrame) {
        return;
      }
      const declarationPath = declarationFrame.replace(/\s*at [^()]*\(([^)]+)\)/, "$1").replace(/^@/, "");
      return declarationPath;
    }
    function isIterable(fn) {
      if (!fn) {
        return false;
      }
      return typeof fn[Symbol.iterator] == "function";
    }
    var defaultContext = {
      status,
      set,
      delay,
      fetch
    };
    var RequestHandler = class {
      constructor(options) {
        this.shouldSkip = false;
        this.ctx = options.ctx || defaultContext;
        this.resolver = options.resolver;
        const callFrame = getCallFrame(new Error());
        this.info = {
          ...options.info,
          callFrame
        };
      }
      parse(_request, _resolutionContext) {
        return null;
      }
      test(request, resolutionContext) {
        return this.predicate(
          request,
          this.parse(request, resolutionContext),
          resolutionContext
        );
      }
      getPublicRequest(request, _parsedResult) {
        return request;
      }
      markAsSkipped(shouldSkip = true) {
        this.shouldSkip = shouldSkip;
      }
      async run(request, resolutionContext) {
        if (this.shouldSkip) {
          return null;
        }
        const parsedResult = this.parse(request, resolutionContext);
        const shouldIntercept = this.predicate(
          request,
          parsedResult,
          resolutionContext
        );
        if (!shouldIntercept) {
          return null;
        }
        const publicRequest = this.getPublicRequest(request, parsedResult);
        const executeResolver = this.wrapResolver(this.resolver);
        const mockedResponse = await executeResolver(
          publicRequest,
          response,
          this.ctx
        );
        return this.createExecutionResult(
          parsedResult,
          publicRequest,
          mockedResponse
        );
      }
      wrapResolver(resolver) {
        return async (req, res, ctx) => {
          const result = this.resolverGenerator || await resolver(req, res, ctx);
          if (isIterable(result)) {
            const { value, done } = result[Symbol.iterator]().next();
            const nextResponse = await value;
            if (!nextResponse && done) {
              return this.resolverGeneratorResult;
            }
            if (!this.resolverGenerator) {
              this.resolverGenerator = result;
            }
            this.resolverGeneratorResult = nextResponse;
            return nextResponse;
          }
          return result;
        };
      }
      createExecutionResult(parsedResult, request, response2) {
        return {
          handler: this,
          parsedResult: parsedResult || null,
          request,
          response: response2 || null
        };
      }
    };
    var restContext = {
      ...defaultContext,
      cookie,
      body,
      text,
      json,
      xml
    };
    var RestRequest = class extends MockedRequest {
      constructor(request, params) {
        super(request.url, {
          ...request,
          body: request["_body"]
        });
        this.params = params;
        this.id = request.id;
      }
    };
    var RestHandler = class extends RequestHandler {
      constructor(method, path, resolver) {
        super({
          info: {
            header: `${method} ${path}`,
            path,
            method
          },
          ctx: restContext,
          resolver
        });
        this.checkRedundantQueryParameters();
      }
      checkRedundantQueryParameters() {
        const { method, path } = this.info;
        if (path instanceof RegExp) {
          return;
        }
        const url = cleanUrl(path);
        if (url === path) {
          return;
        }
        const searchParams = getSearchParams(path);
        const queryParams = [];
        searchParams.forEach((_, paramName) => {
          queryParams.push(paramName);
        });
        devUtils.warn(
          `Found a redundant usage of query parameters in the request handler URL for "${method} ${path}". Please match against a path instead and access query parameters in the response resolver function using "req.url.searchParams".`
        );
      }
      parse(request, resolutionContext) {
        return matchRequestUrl(
          request.url,
          this.info.path,
          resolutionContext == null ? void 0 : resolutionContext.baseUrl
        );
      }
      getPublicRequest(request, parsedResult) {
        return new RestRequest(request, parsedResult.params || {});
      }
      predicate(request, parsedResult) {
        const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);
        return matchesMethod && parsedResult.matches;
      }
      log(request, response2) {
        const publicUrl = getPublicUrlFromRequest(request);
        const loggedRequest = prepareRequest(request);
        const loggedResponse = prepareResponse(response2);
        const statusColor = getStatusCodeColor(response2.status);
        console.groupCollapsed(
          devUtils.formatMessage("%s %s %s (%c%s%c)"),
          getTimestamp(),
          request.method,
          publicUrl,
          `color:${statusColor}`,
          `${response2.status} ${response2.statusText}`,
          "color:inherit"
        );
        console.log("Request", loggedRequest);
        console.log("Handler:", this);
        console.log("Response", loggedResponse);
        console.groupEnd();
      }
    };
    var import_outvariant3 = require_lib();
    var field = (fieldName, fieldValue) => {
      return (res) => {
        validateFieldName(fieldName);
        const prevBody = jsonParse(res.body) || {};
        const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });
        return json(nextBody)(res);
      };
    };
    function validateFieldName(fieldName) {
      (0, import_outvariant3.invariant)(
        fieldName.trim() !== "",
        devUtils.formatMessage(
          "Failed to set a custom field on a GraphQL response: field name cannot be empty."
        )
      );
      (0, import_outvariant3.invariant)(
        fieldName !== "data",
        devUtils.formatMessage(
          'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.data()" instead?',
          fieldName
        )
      );
      (0, import_outvariant3.invariant)(
        fieldName !== "errors",
        devUtils.formatMessage(
          'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.errors()" instead?',
          fieldName
        )
      );
      (0, import_outvariant3.invariant)(
        fieldName !== "extensions",
        devUtils.formatMessage(
          'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.extensions()" instead?',
          fieldName
        )
      );
    }
    function tryCatch(fn, onException) {
      try {
        const result = fn();
        return result;
      } catch (error2) {
        onException == null ? void 0 : onException(error2);
      }
    }
    var graphqlContext = {
      ...defaultContext,
      data,
      extensions,
      errors,
      cookie,
      field
    };
    function isDocumentNode(value) {
      if (value == null) {
        return false;
      }
      return typeof value === "object" && "kind" in value && "definitions" in value;
    }
    var GraphQLRequest = class extends MockedRequest {
      constructor(request, variables, operationName) {
        super(request.url, {
          ...request,
          body: request["_body"]
        });
        this.variables = variables;
        this.operationName = operationName;
      }
    };
    var GraphQLHandler = class extends RequestHandler {
      constructor(operationType, operationName, endpoint, resolver) {
        let resolvedOperationName = operationName;
        if (isDocumentNode(operationName)) {
          const parsedNode = parseDocumentNode(operationName);
          if (parsedNode.operationType !== operationType) {
            throw new Error(
              `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected "${operationType}", but got "${parsedNode.operationType}").`
            );
          }
          if (!parsedNode.operationName) {
            throw new Error(
              `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`
            );
          }
          resolvedOperationName = parsedNode.operationName;
        }
        const header = operationType === "all" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;
        super({
          info: {
            header,
            operationType,
            operationName: resolvedOperationName
          },
          ctx: graphqlContext,
          resolver
        });
        this.endpoint = endpoint;
      }
      parse(request) {
        return tryCatch(
          () => parseGraphQLRequest(request),
          (error2) => console.error(error2.message)
        );
      }
      getPublicRequest(request, parsedResult) {
        var _a, _b;
        return new GraphQLRequest(
          request,
          (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},
          (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : ""
        );
      }
      predicate(request, parsedResult) {
        if (!parsedResult) {
          return false;
        }
        if (!parsedResult.operationName && this.info.operationType !== "all") {
          const publicUrl = getPublicUrlFromRequest(request);
          devUtils.warn(`Failed to intercept a GraphQL request at "${request.method} ${publicUrl}": anonymous GraphQL operations are not supported.

Consider naming this operation or using "graphql.operation()" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);
          return false;
        }
        const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);
        const hasMatchingOperationType = this.info.operationType === "all" || parsedResult.operationType === this.info.operationType;
        const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || "") : parsedResult.operationName === this.info.operationName;
        return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;
      }
      log(request, response2, parsedRequest) {
        const loggedRequest = prepareRequest(request);
        const loggedResponse = prepareResponse(response2);
        const statusColor = getStatusCodeColor(response2.status);
        const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;
        console.groupCollapsed(
          devUtils.formatMessage("%s %s (%c%s%c)"),
          getTimestamp(),
          `${requestInfo}`,
          `color:${statusColor}`,
          `${response2.status} ${response2.statusText}`,
          "color:inherit"
        );
        console.log("Request:", loggedRequest);
        console.log("Handler:", this);
        console.log("Response:", loggedResponse);
        console.groupEnd();
      }
    };
    var MAX_MATCH_SCORE = 3;
    var MAX_SUGGESTION_COUNT = 4;
    var TYPE_MATCH_DELTA = 0.5;
    function groupHandlersByType(handlers) {
      return handlers.reduce(
        (groups, handler) => {
          if (handler instanceof RestHandler) {
            groups.rest.push(handler);
          }
          if (handler instanceof GraphQLHandler) {
            groups.graphql.push(handler);
          }
          return groups;
        },
        {
          rest: [],
          graphql: []
        }
      );
    }
    function getRestHandlerScore() {
      return (request, handler) => {
        const { path, method } = handler.info;
        if (path instanceof RegExp || method instanceof RegExp) {
          return Infinity;
        }
        const hasSameMethod = isStringEqual(request.method, method);
        const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;
        const requestPublicUrl = getPublicUrlFromRequest(request);
        const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);
        return score - methodScoreDelta;
      };
    }
    function getGraphQLHandlerScore(parsedQuery) {
      return (_, handler) => {
        if (typeof parsedQuery.operationName === "undefined") {
          return Infinity;
        }
        const { operationType, operationName } = handler.info;
        if (typeof operationName !== "string") {
          return Infinity;
        }
        const hasSameOperationType = parsedQuery.operationType === operationType;
        const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;
        const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);
        return score - operationTypeScoreDelta;
      };
    }
    function getSuggestedHandler(request, handlers, getScore) {
      const suggestedHandlers = handlers.reduce((suggestions, handler) => {
        const score = getScore(request, handler);
        return suggestions.concat([[score, handler]]);
      }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);
      return suggestedHandlers;
    }
    function getSuggestedHandlersMessage(handlers) {
      if (handlers.length > 1) {
        return `Did you mean to request one of the following resources instead?

${handlers.map((handler) => `  • ${handler.info.header}`).join("\n")}`;
      }
      return `Did you mean to request "${handlers[0].info.header}" instead?`;
    }
    function onUnhandledRequest(request, handlers, strategy = "warn") {
      const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));
      function generateHandlerSuggestion() {
        const handlerGroups = groupHandlersByType(handlers);
        const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;
        const suggestedHandlers = getSuggestedHandler(
          request,
          relevantHandlers,
          parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()
        );
        return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : "";
      }
      function generateUnhandledRequestMessage() {
        const publicUrl = getPublicUrlFromRequest(request);
        const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;
        const handlerSuggestion = generateHandlerSuggestion();
        const messageTemplate = [
          `captured a request without a matching request handler:`,
          `  • ${requestHeader}`,
          handlerSuggestion,
          `If you still wish to intercept this unhandled request, please create a request handler for it.
Read more: https://mswjs.io/docs/getting-started/mocks`
        ].filter(Boolean);
        return messageTemplate.join("\n\n");
      }
      function applyStrategy(strategy2) {
        const message = generateUnhandledRequestMessage();
        switch (strategy2) {
          case "error": {
            devUtils.error("Error: %s", message);
            throw new Error(
              devUtils.formatMessage(
                'Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.'
              )
            );
          }
          case "warn": {
            devUtils.warn("Warning: %s", message);
            break;
          }
          case "bypass":
            break;
          default:
            throw new Error(
              devUtils.formatMessage(
                'Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.',
                strategy2
              )
            );
        }
      }
      if (typeof strategy === "function") {
        strategy(request, {
          warning: applyStrategy.bind(null, "warn"),
          error: applyStrategy.bind(null, "error")
        });
        return;
      }
      applyStrategy(strategy);
    }
    var import_cookies2 = require_lib6();
    function readResponseCookies(request, response2) {
      import_cookies2.store.add({ ...request, url: request.url.toString() }, response2);
      import_cookies2.store.persist();
    }
    async function handleRequest(request, handlers, options, emitter, handleRequestOptions) {
      var _a, _b, _c, _d, _e, _f;
      emitter.emit("request:start", request);
      if (request.headers.get("x-msw-bypass") === "true") {
        emitter.emit("request:end", request);
        (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);
        return;
      }
      const [lookupError, lookupResult] = await (0, import_until.until)(() => {
        return getResponse(
          request,
          handlers,
          handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext
        );
      });
      if (lookupError) {
        emitter.emit("unhandledException", lookupError, request);
        throw lookupError;
      }
      const { handler, response: response2 } = lookupResult;
      if (!handler) {
        onUnhandledRequest(request, handlers, options.onUnhandledRequest);
        emitter.emit("request:unhandled", request);
        emitter.emit("request:end", request);
        (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);
        return;
      }
      if (!response2) {
        devUtils.warn(
          `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.

  • %s
    %s`,
          response2,
          handler.info.header,
          handler.info.callFrame
        );
        emitter.emit("request:end", request);
        (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);
        return;
      }
      if (response2.passthrough) {
        emitter.emit("request:end", request);
        (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);
        return;
      }
      readResponseCookies(request, response2);
      emitter.emit("request:match", request);
      const requiredLookupResult = lookupResult;
      const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;
      (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(
        handleRequestOptions,
        transformedResponse,
        requiredLookupResult
      );
      emitter.emit("request:end", request);
      return transformedResponse;
    }
    var { bold } = import_chalk.default;
    var DEFAULT_LISTEN_OPTIONS = {
      onUnhandledRequest: "warn"
    };
    var SetupServerApi = class extends SetupApi {
      constructor(interceptors, ...handlers) {
        super(...handlers);
        this.interceptor = new import_interceptors2.BatchInterceptor({
          name: "setup-server",
          interceptors: interceptors.map((Interceptor2) => new Interceptor2())
        });
        this.resolvedOptions = {};
        this.init();
      }
      init() {
        this.interceptor.on("request", async (request) => {
          const mockedRequest = new MockedRequest(request.url, {
            ...request,
            body: await request.arrayBuffer()
          });
          const response2 = await handleRequest(
            mockedRequest,
            this.currentHandlers,
            this.resolvedOptions,
            this.emitter,
            {
              transformResponse(response3) {
                return {
                  status: response3.status,
                  statusText: response3.statusText,
                  headers: response3.headers.all(),
                  body: response3.body,
                  delay: response3.delay
                };
              }
            }
          );
          if (response2) {
            if (response2.delay) {
              await new Promise((resolve) => {
                setTimeout(resolve, response2.delay);
              });
            }
            request.respondWith(response2);
          }
          return;
        });
        this.interceptor.on("response", (request, response2) => {
          if (!request.id) {
            return;
          }
          if (response2.headers.get("x-powered-by") === "msw") {
            this.emitter.emit("response:mocked", response2, request.id);
          } else {
            this.emitter.emit("response:bypass", response2, request.id);
          }
        });
      }
      listen(options = {}) {
        this.resolvedOptions = mergeRight(
          DEFAULT_LISTEN_OPTIONS,
          options
        );
        this.interceptor.apply();
        (0, import_outvariant4.invariant)(
          [import_interceptors2.InterceptorReadyState.APPLYING, import_interceptors2.InterceptorReadyState.APPLIED].includes(
            this.interceptor.readyState
          ),
          devUtils.formatMessage(
            'Failed to start "setupServer": the interceptor failed to apply. This is likely an issue with the library and you should report it at "%s".'
          ),
          "https://github.com/mswjs/msw/issues/new/choose"
        );
      }
      printHandlers() {
        const handlers = this.listHandlers();
        handlers.forEach((handler) => {
          const { header, callFrame } = handler.info;
          const pragma = handler.info.hasOwnProperty("operationType") ? "[graphql]" : "[rest]";
          console.log(`${bold(`${pragma} ${header}`)}
  Declaration: ${callFrame}
`);
        });
      }
      close() {
        super.dispose();
        this.interceptor.dispose();
      }
    };
    function setupServer(...handlers) {
      return new SetupServerApi([import_XMLHttpRequest.XMLHttpRequestInterceptor], ...handlers);
    }
  }
});
export default require_native();
//# sourceMappingURL=msw_native.js.map
